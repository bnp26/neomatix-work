#include <zmq.h>
#include <assert.h>
#include <gst/gst.h>
#include <gst/video/video.h>
//#include <gst/app/gstappsrc.h>
#include <stdlib.h>
#include <pthread.h>
#include <unistd.h>

#define WIDTH 160
#define HEIGHT 120

static GMainLoop *loop;

typedef struct _Frame Frame;
typedef struct _Node Node;

struct _Frame {
	guint sourceid;
	uint8_t *data;
	int *frameNum;
	GstClockTime timestamp;
};

struct _Node {
	uint8_t * data;
	struct _Node * next;
};

Frame *frameCtx;
Node *head, *tail;

pthread_t zmq_thr;

void init_queue(void)
{
	head = NULL;
	tail = NULL;
}

void print_queue(void) 
{
	Node *temp = head;
	while(head != NULL)
	{
		printf("[%p, %zu]->", &temp, sizeof(temp->data));
		temp = temp->next;
	}
	printf("NULL\n");
}

int push(uint8_t * newdata)
{
	if(newdata == NULL)
	{
		printf("data can't be null!\n");
		return FALSE;
	}
	if(sizeof(newdata) != WIDTH*HEIGHT)
	{
		printf("data must be of size %i\n", WIDTH*HEIGHT);
		return FALSE;
	}

	Node *temp = (Node*)malloc(sizeof(Node));
	
	temp->data = newdata;
	temp->next = NULL;

	if(head == NULL && tail == NULL)
	{
		head = tail = temp;
		print_queue();
		return TRUE;
	}

	tail->next = temp;
	tail = temp;
	print_queue();
	return TRUE;
}

uint8_t * pop(void)
{
	if(head == NULL) 
	{
		printf("Queue is Empty\n");
		return NULL;
	}
	Node *temp = head;
	uint8_t *rdata;
	rdata = temp->data;

	if(head == tail)
		head = tail = NULL;
	else
	{
		head = head->next;
		free(temp);
	}
	print_queue();
	return rdata;
}

uint8_t * peek(void)
{
	if(head == NULL)
	{
		printf("Queue is empty\n");
		return NULL;
	}
	return head->data;
}


void* zmq_thread(void *data)
{
	void *context, *subscriber;
	int rc;

	context = zmq_ctx_new();
	subscriber = zmq_socket(context, ZMQ_SUB);
	rc = zmq_connect (subscriber, "tcp://127.0.0.1:5556");
	if(rc == 0)
		printf("connected to tcp://127.0.0.1:5556\n");
	else
	{
		printf("failed to connect to server\n");
		return NULL;
	}
	
	rc = zmq_setsockopt (subscriber, ZMQ_SUBSCRIBE, "", 0);
	
	if(rc != -1)
		printf("subscribed to client\n");
	else
	{
		printf("could not subscribe to client\n");
		return NULL;
	}
	
	while (1) {
		zmq_msg_t msg;
		rc = zmq_msg_init (&msg);
		if(rc == -1)
		{
			printf("could not init msg!\n");
			return NULL;
		}
		rc = zmq_msg_recv(&msg, subscriber,  0);
		
		if(rc == -1)
		{	
			printf("didn't recieve any data, sleeping for a second.\n");
			sleep(1);
		}
		else
		{
			push(zmq_msg_data(&msg));
		}
		rc = zmq_msg_close(&msg);
	}
	
	printf("about to close\n");

	zmq_close (subscriber);
	zmq_ctx_destroy (context);
	return NULL;
}

void gst_controller_zmq_thr_creat(void)
{
	int ret;

	pthread_attr_t attr;

	pthread_attr_init(&attr);

	ret = pthread_create(&zmq_thr, &attr, zmq_thread, NULL);
	if(ret != 0)
	{
		printf("could not create new thread!\n");
		return;
	}

	pthread_attr_destroy(&attr);
	return;
}

static gboolean need_data (GstElement * appsrc, guint size, Frame * frame)
{

	GstBuffer *buffer;
	GstFlowReturn ret;
	
	//popped data
	uint8_t *  pdata = pop();

	buffer = gst_buffer_new_wrapped((gpointer)pdata, sizeof(pdata));

	GST_BUFFER_PTS (buffer) = frame->timestamp;	
	GST_BUFFER_DURATION (buffer) = gst_util_uint64_scale_int (1, GST_SECOND, 16);
	frame->timestamp += GST_BUFFER_DURATION(buffer);
	frame->frameNum += 1;
	
	g_signal_emit_by_name (appsrc, "push-buffer", buffer, &ret);	

	if (ret != GST_FLOW_OK)
	{
		g_main_loop_quit (loop);
	}
	return TRUE;
}                              

int main(int argc, char *argv[])
{
	int major, minor, patch;
	zmq_version (&major, &minor, &patch);
	GstElement *pipeline, *source, *converter, *sink;
	GstCaps *filtercaps;

  	frameCtx = g_new0(Frame, 1);
	frameCtx->data = malloc(160 * 120);
	frameCtx->frameNum = 0;
	frameCtx->timestamp = 0;

	init_queue();
	gst_controller_zmq_thr_creat();	

	gst_init (&argc, &argv);
	loop = g_main_loop_new(NULL, FALSE);

	// create gstreamer elements 
	//gst-launch-1.0 videotestsrc ! videoparse ! queue ! videoconvert ! x264enc ! udpsink host=127.0.0.1 port=8000
	pipeline = gst_pipeline_new("camera-one-video-player");	
	source = gst_element_factory_make ("appsrc", "app-src");
	converter = gst_element_factory_make ("videoconvert", "converter"); 
	sink = gst_element_factory_make("xvimagesink", "sink");
	
	if (!pipeline || !source || !converter || !sink) {
		g_printerr ("Some elements could not be created. Exiting.\n");
		return -1;
	}
	
	filtercaps = gst_caps_new_simple ("video/x-raw",
			   "format", G_TYPE_STRING, "GRAY8",
			   "width", G_TYPE_INT, 160,
			   "height", G_TYPE_INT, 120,
			   "framerate", GST_TYPE_FRACTION, 16, 1,
			   NULL);

	g_object_set(G_OBJECT (source),
		"stream-type", 0,
		"max-bytes", 19200,
		"caps", filtercaps,
		"size", -1,
		NULL);

	gst_caps_unref (filtercaps);

	gst_bin_add_many (GST_BIN (pipeline), source, converter, sink, NULL);
	
	gst_element_link_many (source, converter, sink, NULL);
	
	g_printerr("configured data, frameNum, timestamp, context, and the subscriber socket\n");

	g_printerr ("Current 0MQ version is %d.%d.%d\n", major, minor, patch);

	g_signal_connect (source, "need-data", G_CALLBACK (need_data), frameCtx);
	
	//play
	gst_element_set_state (pipeline, GST_STATE_PLAYING);
	g_printerr("PLAY");
	g_main_loop_run (loop);
	
	//stop playing
	gst_element_set_state (pipeline, GST_STATE_NULL);
	g_printerr("STOP");

	// clean up 
	
	void *retval;
	pthread_join(zmq_thr, &retval);
	pthread_exit(retval);
	free(frameCtx->data);
	gst_object_unref (GST_OBJECT (source));
	gst_object_unref (GST_OBJECT (converter));
	gst_object_unref (GST_OBJECT (sink));
	gst_object_unref (GST_OBJECT (pipeline));

	g_main_loop_unref (loop);

	return 0;
}
